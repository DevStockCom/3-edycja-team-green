                 /* 
                1. Napisz funkcję mapującą, która utworzy klucz(właściwość) nickname na każdej osobie w tablicy w następujący sposób:
                a) pobierze 3 pierwsze litery imienia, odwróci ich kolejność i zapisze do zmiennej
                //onazoL
                //Lozano
                b) pobierze 3 ostatnie litery nazwiska, zamieni kolejnością pierwszą i ostatnią i dołączy powstały string do poprzedniego
                c*) Zmieni wielkość liter w taki sposób, żeby powstały nick zaczynał się wielką literą i nie miał żadnych wielkich liter poza 1.
                d) Jeżeli liczba znaków w imieniu bądź nazwisku jest mniejsza niż 3, nickname będzie odpowiednio krótszy 
                e) rozważcie wszystkie skrajne przypadki, ponieważ Waszą funkcję mapującą wrzucimy do testów na platformie
                e) Have fun :)
                /*

const people = [
    {
      firstName: "Bartolomeo",
      lastName: "Lozano",
    },
    {
      firstName: "Mateo",
      lastName: "Loza",
    },
    {
      firstName: "Al",
      lastName: "Capone",
    },
    {
      firstName: "Harry",
      lastName: "Up",
    },
  ];

  let peopleMapped = people.map(function(item) {
    if (item.firstName.length < 3 || item.lastName.length < 3 ) {
      let nickname1 = item.firstName.substring(0, 2).split('').reverse().join('').toLowerCase()
let nickname2 = item.lastName.slice(-2).split('').reverse().join('').toLowerCase()
let nickname =  nickname1 + nickname2
 return nickname.charAt(0).toUpperCase() + nickname.slice(1)
    }  
let nickname1 = item.firstName.substring(0, 3).split('').reverse().join('').toLowerCase()
let nickname2 = item.lastName.slice(-3).split('').reverse().join('').toLowerCase()
let nickname =  nickname1 + nickname2
 return nickname.charAt(0).toUpperCase() + nickname.slice(1)
  })
let result = peopleMapped;
  console.log(result);

                  /* 
                      2. 
                      a) Do każdego obiektu dodaj funkcję introduceYourself, która za pomocą słówka this wyświetli w konsoli tekst powitalny.
                      Oczywiście tekst powinien wyświetlić się dopiero po wywołaniu funkcji.
                      Dla powyższego przykładu tekst powinien wyglądać w następujący sposób:
                      "Cześć jestem Bartolomeo Lozano, ale w szkole mówią na mnie [Rabona]"
                      Natomiast wywołanie funkcji: people[0].introduceYourself()
                  /*
  const people1 = [
    {
      firstName: "Bartolomeo",
      lastName: "Lozano",
      nickname: "Rabona",
      introduceYourself: function() {
        return  `Cześć jestem ${this.firstName} ${this.lastName}, ale w szkole mówią na mnie ${this.nickname}.`
      }
      },
      {
        firstName: "Mateo",
        lastName: "Loza",
        nickname: "Tamazo",
        introduceYourself: function() {
          return  `Cześć jestem ${this.firstName} ${this.lastName}, ale w szkole mówią na mnie ${this.nickname}.`
        }
        },
        {
          firstName: "Al",
          lastName: "Capome",
          nickname: "Laen",
          introduceYourself: function() {
            return  `Cześć jestem ${this.firstName} ${this.lastName}, ale w szkole mówią na mnie ${this.nickname}.`
          }
          }
    ,
  ];

  console.log(people1)

b) za pomocą pętli forEach, wywołaj funkcję powitalną dla każdego elementu tablicy. W rezultacie na ekranie powinien
    pojawić się tekst powitalny dla każdej osoby w tablicy
    Hints:


  let newArray = people1.forEach(function(item) {
    console.log(`Cześć jestem ${item.firstName} ${item.lastName}, ale w szkole mówią na mnie ${item.nickname}.`)
    })
    

                        /*
                        3. 
                        a) Dodaj do każdego obiektu funkcję getFavouriteColor
                        b) funkcja ma przyjmować jeden parametr typu number z zakresu 1 - 30
                        c) jeżeli podany parametr jest poza zakresem, powinien wyświetlić się odpowiedni komunikat
                            - podałeś za małą liczbę, liczba nie może być mniejsza niż 1
                            - podałeś za dużą liczbę, liczba nie może być większa niż 30
                        d) w przypadku wywołania funkcji bez parametru, powinniśmy ustawić domyślną wartość na 5
                        e) funkcja powinna zsumować wszystkie litery imienia, nazwiska i przezwiska, 
                        odjąć od tej sumy liczbę wprowadzoną w parametrze, a następnie za pomocą działania modulo (%) względem długości tablicy kolorów
                        wyznaczyć index
                        f) za pomocą indexu funkcja powinna wyciągnąć odpowiedni kolor z tablicy i wyświetlić go w konsoli.
                        /*

    
    
    const people = [
      {
        firstName: "Bartolomeo",
        lastName: "Lozano",
        nickname: "Rabona",
        getFavouriteColor: function(number) {
          if (number < 1) {
            return `podałeś za małą liczbę, liczba nie może być mniejsza niż 1`
          } else if (number > 30) {
            return `podałeś za dużą liczbę, liczba nie może być większa niż 30`
          } number = number || 5
          let sum = this.firstName.length + this.lastName.length + this.nickname.length
          let last = colors.length
          let index = Math.abs(sum - number) % last
          console.log(index)
          return colors[index]
        } 
      },
    ];
    const colors = ["red", "green", "yellow", "blue", "pink", "orange", "purple", "mint", "sea"];
    
    let result = people[0].getFavouriteColor(14)

    console.log(result)


    const people1 = [
      {
        firstName: "Bartolomeo",
        lastName: "Lozano",
        nickname: "Rabona",
        getFavouriteColor: function(number) {
          if (number < 1) {
            return `podałeś za małą liczbę, liczba nie może być mniejsza niż 1`
          } else if (number > 30) {
            return `podałeś za dużą liczbę, liczba nie może być większa niż 30`
          } number = number || 5
          let sum = this.firstName.length + this.lastName.length + this.nickname.length
          let last = colors.length
          let index = Math.abs(sum - number) % last
          console.log(index)
          let result = colors[index]
          return result
        }
        },
        {
          firstName: "Mateo",
          lastName: "Loza",
          nickname: "Tamazo",
          getFavouriteColor: function(number) {
            if (number < 1) {
              return `podałeś za małą liczbę, liczba nie może być mniejsza niż 1`
            } else if (number > 30) {
              return `podałeś za dużą liczbę, liczba nie może być większa niż 30`
            } number = number || 5
            let sum = this.firstName.length + this.lastName.length + this.nickname.length
            let last = colors.length
            let index = Math.abs(sum - number) % last
            console.log(index)
            return colors[index]
          }
          }
          ,
          {
            firstName: "Al",
            lastName: "Capome",
            nickname: "Laen",
            getFavouriteColor: function(number) {
              if (number < 1) {
                return `podałeś za małą liczbę, liczba nie może być mniejsza niż 1`
              } else if (number > 30) {
                return `podałeś za dużą liczbę, liczba nie może być większa niż 30`
              } number = number || 5
              let sum = this.firstName.length + this.lastName.length + this.nickname.length
              let last = colors.length
              let index = Math.abs(sum - number) % last
              console.log(index)
              return colors[index]
            }
            }
            
      ,
    ];
    const colors = ["red", "green", "yellow", "blue", "pink", "orange", "purple", "mint", "sea"];
    
    
                      /*
                      4. Napisz funkcję analogiczną do funkcji z zadania 3, ale nie dodawaj jej w obiekcie.
                      a) funkcja powinna przyjąć 2 parametry (obiekt osoby i liczbę z zakresu 1 - 30)
                      b) funkcja powinna wykonać dokładnie takie samo działanie jak poprzednia
                      c) Za pomocą pętli for of przeiteruj po wszystkich osobach z tablicy i wyświetl ich ulubione kolory
                      */
    
    
   let getFavouriteColor2 = function(people1 ,number) {
            if (number < 1) {
              return `podałeś za małą liczbę, liczba nie może być mniejsza niż 1`
            } else if (number > 30) {
              return `podałeś za dużą liczbę, liczba nie może być większa niż 30`
            } number = number || 5
            let sum = people1.firstName.length + people1.lastName.length + people1.nickname.length
            let last = colors.length
            let index = Math.abs(sum - number) % last
            console.log(index)
            return colors[index]
          }
        
      const colors = ["red", "green", "yellow", "blue", "pink", "orange", "purple", "mint", "sea"];

      let result = getFavouriteColor2(people1[2], 3)
      console.log(result)

      for (const value of people1) {
        console.log(value.getFavouriteColor(5));
      }


              /*
                  5. Zadanie polega na użyciu .filter() .map() .reduce w wersji łańcuchowej,
                  czyli nie twórz nowych tablic w momencie wykonanie jednej z powyższych metod, połącz wykonanie ze sobą w jeden 
                  "łańcuch" tzn. const wynik = arr.filter().map().reduce()
                  a) Przefiltruj tablicę w taki sposób, aby zostały w niej osoby,
                  których imię kończy się na literę 'a' lub 'k' 
                  i nazwisko ma więcej znaków niż 6 
                  i nick zawiera w sobie przynajmniej jedną literę a
                  b) do powyższego warunku dodaj "furtkę" w postaci parametru isElite. Zmienna isElite powinna być obliczona
                  za pomocą generatora liczb pseudolosowych Math.random(). Za pomocą tego generatora wylosujcie liczbę z zakresu 0 - 100.
                  Jeżeli wartość losowej liczby będzie liczbą pierwszą lub będzie podzielna przez 3 i 5, ustawcie isElite na true, w pozostałych przypadkach
                  isElite powinno być ustawione na false
                  c) jeżeli zmienna isElite ma wartość true, nie bierzcie pod uwagę warunku z punktu a przy filtracji
                  d) za pomocą funkcji map i for in odwróccie wartości i klucze w obiekcie, usuwając przy tym funkcje
                  e) zredukuj tablicę obiektów do pojedynczego obiektu, który będzie zawierał wszystkie klucze i wartości
                  wszystkich obiektów z tablicy, dzięki temu, że w punkcie d) odwrócilismy klucze z wartościami, nie będzie 
                  z tym problemu :)
                  g) posortuj tablicę alfabetycznie
              /*


      const people1 = [
        {
          firstName: "Bartek",
          lastName: "Lozanone",
          nickname: "Rabona",
          introduceYourself: function() {
                      return  `Cześć jestem ${this.firstName} ${this.lastName}, ale w szkole mówią na mnie ${this.nickname}`
                    },
           getFavouriteColor2: function(people1 ,number) {
                      if (number < 1) {
                      return `podałeś za małą liczbę, liczba nie może być mniejsza niż 1`
                       } else if (number > 30) {
                       return `podałeś za dużą liczbę, liczba nie może być większa niż 30`
                       } number = number || 5
                        let sum = people1.firstName.length + people1.lastName.length + people1.nickname.length
                        let last = colors.length
                        let index = Math.abs(sum - number) % last
                        console.log(index)
                       return colors[index]
                       }
        },
          {
            firstName: "Matea",
            lastName: "Mati",
            nickname: "Tamazo",
            introduceYourself: function() {
              return  `Cześć jestem ${this.firstName} ${this.lastName}, ale w szkole mówią na mnie ${this.nickname}`
            },
            getFavouriteColor2: function(people1 ,number) {
              if (number < 1) {
                return `podałeś za małą liczbę, liczba nie może być mniejsza niż 1`
              } else if (number > 30) {
                return `podałeś za dużą liczbę, liczba nie może być większa niż 30`
              } number = number || 5
              let sum = people1.firstName.length + people1.lastName.length + people1.nickname.length
              let last = colors.length
              let index = Math.abs(sum - number) % last
              console.log(index)
              return colors[index]
            }
            },
            {
              firstName: "Al",
              lastName: "Capome",
              nickname: "Laen",
              introduceYourself: function() {
                return  `Cześć jestem ${this.firstName} ${this.lastName}, ale w szkole mówią na mnie ${this.nickname}`
              },
              getFavouriteColor2: function(people1 ,number) {
                if (number < 1) {
                  return `podałeś za małą liczbę, liczba nie może być mniejsza niż 1`
                } else if (number > 30) {
                  return `podałeś za dużą liczbę, liczba nie może być większa niż 30`
                } number = number || 5
                let sum = people1.firstName.length + people1.lastName.length + people1.nickname.length
                let last = colors.length
                let index = Math.abs(sum - number) % last
                console.log(index)
                return colors[index]
              }
              }
              
        ,
      ];
      // const colors = ["red", "green", "yellow", "blue", "pink", "orange", "purple", "mint", "sea"];

      // console.log(people1)


const newArray1 = people1.filter(function(item) {
 if (item.firstName.endsWith("a") == true) {
    return item 
  } else if (item.firstName.endsWith("k") == true) {
    return item
  } 
})

  console.log(newArray1)


let isElite = Math.floor(Math.random() * 100)
if (isElite > 0 && isElite < 10 || isElite % 3 == 0 && isElite % 5 == 0) {
isElite = true
 } else {
 isElite = false }
 console.log(isElite)
 

const newArray = people1.filter(function(item)  {
 if (item.firstName.endsWith("a") == true && item.lastName.length > 6 && item.nickname.includes("a") && isElite == false ||
  item.firstName.endsWith("k") == true && item.lastName.length > 6 && item.nickname.includes("a") && isElite == false) {
    return item}
}
)
console.log(newArray)

 const result = people1.map(({firstName, lastName, nickname }) => {
    let result1 = {
      firstName,
      lastName,
      nickname
    }; return Object.assign({}, ...Object.entries(result1).map(([a,b]) => ({ [b]: a })))
    }
    ); 
    console.log(result)

    function combineObjects(arr) {
      return arr.reduce((acc, o) => {
        return { ...o,  ...acc };
      }, {});
    }
    let result2 = combineObjects(result);

    const finalResult = Object.keys(result2).sort().reduce(
      (obj, key) => { 
        obj[key] = result2[key]; 
        return obj;
      }, 
      {}
    );
    
   console.log(finalResult)

                  /*
                      *6. Currying function
                      a) Napisz taką funkcję mnożącą 2 liczby, aby możliwe były następujące wywołania:
                      - multi(5)(6)
                      - const multiplyBySix = sum(6)
                        multiplyBySix(10)
                      b) Analogicznie napisz funkcję, która mnoży 4 liczby i możliwe jest wywołanie
                      - multi(4)(5)(6)(10)
                  /*

const sum =(a) => {
    return (b) => {
    return a*b
    }
    }
    console.log(sum(5)(6)) 
    const multiplyBySix = sum(6)
    console.log(multiplyBySix(10)) 


    const multi =(a) => {
    return (b) => {
    return (c) => {
    return (d) => {
    return a*b*c*d
    }
    }
    }
    }
    console.log(multi(4)(5)(6)(10)) 

                /*
                **7. Rekurencja
                a) Mając zagnieżdżony obiekt, wyciągnij z niego wszystkie imiona i dodaj do tablicy
                ***b) Jeżeli osoba ma więcej niż jedno imię, te imiona powinny znajdować się w jednym stringu w tablicy
                Na przykład 'Kamil Bartek'
                /*


const nestedObject = {
 name: "Kamil",
 children: [
   {
     name: "Zosia",
   },
   {
     name: "Krysia",
     name2: "Barbara",
     children: [
       {
         name: "Basia",
         children: [
           {
             name: "Monika",
             name2: "Viola",
             children: [
               {
                 name: "Mateusz",
               },
               {
                 name: "Sebastian",
                 name2: "August",
                 name3: "Franciszek",
                 children: [
                   { name: "Alex" },
                   { name: "Stasio" },
                   {
                     name: "Paulina",
                     children: [{ name: "Kuba" }, { name: "Kacper" }],
                   },
                 ],
               },
             ],
           },
         ],
       },
     ],
   },
 ],
};


       function toArray1(obj) {
        var result = [];
          for (const prop in obj) {
              const value = obj[prop];
              if (typeof value === 'object') {
                  result = result.concat(" " + toArray1(value));
              }
              else {
                  result = result.concat(value);
              }
          }
          return result.toString()
      }
      let finalResult = toArray1(nestedObject)
      let finalResult1 = finalResult.split(` `)
      let array = finalResult1.filter(e => e !== ``)
        console.log(array) 
 



 

